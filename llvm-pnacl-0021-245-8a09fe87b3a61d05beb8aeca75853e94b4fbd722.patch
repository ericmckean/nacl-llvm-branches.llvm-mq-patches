# HG changeset patch
# User Jason Kim <jasonwkim@google.com>
# Date 1301606360 25200
# Branch pnacl-sfi
# Node ID 8a09fe87b3a61d05beb8aeca75853e94b4fbd722
# Parent 0efd1503eb3078142dfd50b1a219ab8433c37618
Revert bb23f96ef85a.

The switch changes (i.e. -linux to -nacl) breaks GCC-x86_64-none-linux-gnu stage 1
This is needed to update LLVM_REV in utman.sh to a more recent version.

BUG=none
TEST=none

 From llvm-pnacl-0021-245-8a09fe87b3a61d05beb8aeca75853e94b4fbd722.patch

 From .hg/patches/llvm-pnacl-0021-245-8a09fe87b3a61d05beb8aeca75853e94b4fbd722.patch.stripped

diff -r 0efd1503eb30 lib/Support/Triple.cpp
--- a/lib/Support/Triple.cpp	Thu Mar 31 10:56:04 2011 -0400
+++ b/lib/Support/Triple.cpp	Wed Jun 29 12:00:02 2011 -0700
@@ -314,8 +314,8 @@
     return FreeBSD;
   else if (OSName.startswith("linux"))
     // TODO(pdox): Fix this when we stop using target linux
-    return Linux;
-    //return NativeClient; // @LOCALMOD
+    //return Linux;
+    return NativeClient; // @LOCALMOD
   else if (OSName.startswith("lv2"))
     return Lv2;
   else if (OSName.startswith("mingw32"))
diff -r 0efd1503eb30 lib/Target/ARM/ARMAsmPrinter.cpp
--- a/lib/Target/ARM/ARMAsmPrinter.cpp	Thu Mar 31 10:56:04 2011 -0400
+++ b/lib/Target/ARM/ARMAsmPrinter.cpp	Wed Jun 29 12:00:02 2011 -0700
@@ -58,8 +58,8 @@
 
 // @LOCALMOD-START
 namespace llvm {
-  extern cl::opt<bool> FlagSfiDisableBranch;
-  extern cl::opt<bool> FlagSfiDisableData;
+  extern cl::opt<bool> FlagSfiBranch;
+  extern cl::opt<bool> FlagSfiData;
 }
 // @LOCALMOD-END
 
@@ -265,7 +265,7 @@
   MCP = MF.getConstantPool();
 
   // @LOCALMOD-START
-  if (Subtarget->isTargetNaCl() && (!FlagSfiDisableBranch)) {
+  if (FlagSfiBranch) {
     NaclAlignAllJumpTargetsAndConstantPools(MF);
   }
   // @LOCALMOD-END
@@ -1366,7 +1366,7 @@
         OutStreamer.EmitRawText(StringRef("sfi_nop_if_at_bundle_end\n"));
       }
 
-      if (!FlagSfiDisableData) {
+      if (FlagSfiData) {
         SmallString<128> Str;
         raw_svector_ostream OS(Str);
         OS << "sfi_illegal_if_at_bundle_begining  @ ========== SFI (" << 
diff -r 0efd1503eb30 lib/Target/ARM/ARMAsmPrinter.h
--- a/lib/Target/ARM/ARMAsmPrinter.h	Thu Mar 31 10:56:04 2011 -0400
+++ b/lib/Target/ARM/ARMAsmPrinter.h	Wed Jun 29 12:00:02 2011 -0700
@@ -73,8 +73,7 @@
   // For the sfi case we do not use the custom logic and fall back
   // to the default implementation.
   virtual void EmitConstantPool() {
-    if (Subtarget->isTargetNaCl() && (!FlagSfiEnableCP))
-      AsmPrinter::EmitConstantPool();
+    if (FlagSfiDisableCP) AsmPrinter::EmitConstantPool();
   }
   // @LOCALMOD-END
 
diff -r 0efd1503eb30 lib/Target/ARM/ARMBaseRegisterInfo.cpp
--- a/lib/Target/ARM/ARMBaseRegisterInfo.cpp	Thu Mar 31 10:56:04 2011 -0400
+++ b/lib/Target/ARM/ARMBaseRegisterInfo.cpp	Wed Jun 29 12:00:02 2011 -0700
@@ -848,7 +848,7 @@
   // Sadly, the ARM backend is not very consistent about using this
   // pseudo instr. and hence checking this is not sufficient.
   // But, it should help detect some regressions early.
-  assert ((!STI.isTargetNaCl()) && "unexpected call to emitLoadConstPool");
+  assert(!FlagSfiDisableCP && "unexpected call to emitLoadConstPool");
   // @LOCALMOD-END
   MachineFunction &MF = *MBB.getParent();
   MachineConstantPool *ConstantPool = MF.getConstantPool();
diff -r 0efd1503eb30 lib/Target/ARM/ARMConstantIslandPass.cpp
--- a/lib/Target/ARM/ARMConstantIslandPass.cpp	Thu Mar 31 10:56:04 2011 -0400
+++ b/lib/Target/ARM/ARMConstantIslandPass.cpp	Wed Jun 29 12:00:02 2011 -0700
@@ -319,6 +319,7 @@
 }
 
 bool ARMConstantIslands::runOnMachineFunction(MachineFunction &MF) {
+  if (FlagSfiDisableCP) return false;   // @LOCALMOD
   MachineConstantPool &MCP = *MF.getConstantPool();
 
   TII = (const ARMInstrInfo*)MF.getTarget().getInstrInfo();
@@ -326,9 +327,6 @@
   AFI = MF.getInfo<ARMFunctionInfo>();
   STI = &MF.getTarget().getSubtarget<ARMSubtarget>();
 
-  if (STI->isTargetNaCl() && (!FlagSfiEnableCP)) // @LOCALMOD
-    return false;   // @LOCALMOD
-  
   isThumb = AFI->isThumbFunction();
   isThumb1 = AFI->isThumb1OnlyFunction();
   isThumb2 = AFI->isThumb2Function();
@@ -626,7 +624,7 @@
 }
 
 static void UpdateJumpTargetAlignment(MachineFunction &MF) {
-  if (FlagSfiDisableBranch) return;
+  if (!FlagSfiBranch) return;
 
   // JUMP TABLE TARGETS
   MachineJumpTableInfo *jt_info = MF.getJumpTableInfo();
diff -r 0efd1503eb30 lib/Target/ARM/ARMExpandPseudoInsts.cpp
--- a/lib/Target/ARM/ARMExpandPseudoInsts.cpp	Thu Mar 31 10:56:04 2011 -0400
+++ b/lib/Target/ARM/ARMExpandPseudoInsts.cpp	Wed Jun 29 12:00:02 2011 -0700
@@ -730,8 +730,8 @@
   // We need to know if it matters that references are pc-relative
   // (e.g., to be PIC).
   // See the comments on MOVi16PIC / MOVTi16PIC for more details.
-  const bool ShouldUseMOV16PIC = (!FlagSfiEnableCP) && IsRelocPIC &&
-    (STI->isTargetNaCl() ||  MO.isCPI() || MO.isJTI() || MO.isGlobal()); // TODO check this list.
+  const bool ShouldUseMOV16PIC = FlagSfiDisableCP && IsRelocPIC &&
+      (MO.isCPI() || MO.isJTI() || MO.isGlobal()); // TODO check this list.
   if (ShouldUseMOV16PIC) {
     if (isThumb2)
       llvm_unreachable("FIXME: add PIC versions of t2MOVi16");
diff -r 0efd1503eb30 lib/Target/ARM/ARMFastISel.cpp
--- a/lib/Target/ARM/ARMFastISel.cpp	Thu Mar 31 10:56:04 2011 -0400
+++ b/lib/Target/ARM/ARMFastISel.cpp	Wed Jun 29 12:00:02 2011 -0700
@@ -547,8 +547,7 @@
   // @LOCALMOD-START
   // In the sfi case we do not want to use the ARM custom cp handling.
   // This assert should help detect some regressions early.
-  assert((!Subtarget->isTargetNaCl() || FlagSfiEnableCP) && 
-         "unexpected call to TargetMaterializeConstant");
+  assert(!FlagSfiDisableCP && "unexpected call to TargetMaterializeConstant");
   // @LOCALMOD-END
   EVT VT = TLI.getValueType(C->getType(), true);
 
diff -r 0efd1503eb30 lib/Target/ARM/ARMISelDAGToDAG.cpp
--- a/lib/Target/ARM/ARMISelDAGToDAG.cpp	Thu Mar 31 10:56:04 2011 -0400
+++ b/lib/Target/ARM/ARMISelDAGToDAG.cpp	Wed Jun 29 12:00:02 2011 -0700
@@ -38,7 +38,7 @@
 // @LOCALMOD-START
 #include "llvm/Support/CommandLine.h"
 namespace llvm {
-  extern cl::opt<bool> FlagSfiDisableStore;
+  extern cl::opt<bool> FlagSfiStore;
 }
 // @LOCALMOD-END
 
@@ -438,7 +438,7 @@
   SDValue& N, const ARMSubtarget* Subtarget) {
   assert (N.getOpcode() == ARMISD::Wrapper);
   // Never use this transformation if constant island pools are disallowed 
-  if (Subtarget->isTargetNaCl() && (!FlagSfiEnableCP)) return false;
+  if (FlagSfiDisableCP) return false;
 
   // always apply this when we do not have movt/movw available
   // (if we do have movt/movw we be able to get rid of the
@@ -618,7 +618,7 @@
   // @LOCALMOD-START
   // avoid two reg addressing mode for stores
   const bool is_store = (Op->getOpcode() == ISD::STORE);
-  if (FlagSfiDisableStore || !is_store ) {
+  if (!FlagSfiStore || !is_store ) {
   // @LOCALMOD-END
 
   if (N.getOpcode() == ISD::MUL &&
@@ -701,7 +701,7 @@
   
   // @LOCALMOD-START
   // keep store addressing modes simple
-  if ((!FlagSfiDisableStore) && is_store) {
+  if (FlagSfiStore && is_store) {
     Base = N;
     if (N.getOpcode() == ISD::FrameIndex) {
       int FI = cast<FrameIndexSDNode>(N)->getIndex();
@@ -801,7 +801,7 @@
 
     //if (ConstantSDNode *Sh = dyn_cast<ConstantSDNode>(N.getOperand(1))) {
     ConstantSDNode *Sh = dyn_cast<ConstantSDNode>(N.getOperand(1));
-    if ((FlagSfiDisableStore || !is_store) && Sh ) { // @LOCALMOD
+    if ((!FlagSfiStore || !is_store) && Sh ) { // @LOCALMOD
       ShAmt = Sh->getZExtValue();
       if (isShifterOpProfitable(N, ShOpcVal, ShAmt))
         Offset = N.getOperand(0);
@@ -825,7 +825,7 @@
                                       SDValue &Opc) {
   // @LOCALMOD-START
   const bool is_store = (Op->getOpcode() == ISD::STORE);
-  if (FlagSfiDisableStore ||!is_store) {
+  if (!FlagSfiStore ||!is_store) {
   // @LOCALMOD-END
   if (N.getOpcode() == ISD::SUB) {
 
@@ -869,7 +869,7 @@
   }
 
   // @LOCALMOD-START
-  if (!FlagSfiDisableStore && is_store) {
+  if (FlagSfiStore && is_store) {
     Base = N;
     Offset = CurDAG->getRegister(0, MVT::i32);
     Opc = CurDAG->getTargetConstant(ARM_AM::getAM3Opc(ARM_AM::add, 0),MVT::i32);
@@ -2307,8 +2307,7 @@
                  !ARM_AM::isSOImmTwoPartVal(Val));     // two instrs.
     }
 
-    if (Subtarget->isTargetNaCl() && (!FlagSfiEnableCP)) 
-      UseCP = false; // @LOCALMOD
+    if (FlagSfiDisableCP) UseCP = false; // @LOCALMOD
 
     if (UseCP) {
       SDValue CPIdx =
diff -r 0efd1503eb30 lib/Target/ARM/ARMISelLowering.cpp
--- a/lib/Target/ARM/ARMISelLowering.cpp	Thu Mar 31 10:56:04 2011 -0400
+++ b/lib/Target/ARM/ARMISelLowering.cpp	Wed Jun 29 12:00:02 2011 -0700
@@ -55,8 +55,8 @@
 // @LOCALMOD-START
 #include "llvm/Support/CommandLine.h"
 namespace llvm {
-  extern cl::opt<bool> FlagSfiDisableStore;
-  extern cl::opt<bool> FlagSfiEnableCP;
+  extern cl::opt<bool> FlagSfiStore;
+  extern cl::opt<bool> FlagSfiDisableCP;
 }
 // @LOCALMOD-END
 
@@ -1924,7 +1924,7 @@
   SDValue Chain;
   SDValue Argument;
 
-  if (Subtarget->isTargetNaCl() && (!FlagSfiEnableCP)) {
+  if (FlagSfiDisableCP) {
     // With constant pools "disabled" (moved to rodata), this constant pool
     // entry is no longer in text, and simultaneous PC relativeness
     // and CP Addr relativeness is no longer expressible.
@@ -2016,7 +2016,7 @@
     unsigned ARMPCLabelIndex = AFI->createPICLabelUId();
 
     // @LOCALMOD-BEGIN
-    if (Subtarget->isTargetNaCl() && (!FlagSfiEnableCP)) {
+    if (FlagSfiDisableCP) {
       // Similar to change to LowerToTLSGeneralDynamicModel, and
       // for the same reason.
       unsigned char PCAdj = 0;
@@ -2205,7 +2205,7 @@
   DebugLoc dl = Op.getDebugLoc();
 
   // @LOCALMOD-BEGIN
-  if (Subtarget->isTargetNaCl() && !(FlagSfiEnableCP)) {
+  if (FlagSfiDisableCP) {
     // With constant pools "disabled" (moved to rodata), the constant pool
     // entry is no longer in text, and the PC relativeness is
     // no longer expressible.
@@ -6702,7 +6702,7 @@
 
   // @LOCAMOD-START
   // NOTE: THIS IS A LITTLE DRASTIC
-  if (!FlagSfiDisableStore && N->getOpcode() == ISD::STORE) {
+  if (FlagSfiStore && N->getOpcode() == ISD::STORE) {
     return false;
   }
   // @LOCAMOD-END
@@ -6747,7 +6747,7 @@
     return false;
    // @LOCALMOD-START
   // THIS IS A LITTLE DRASTIC
-  if ((!FlagSfiDisableStore) && N->getOpcode() == ISD::STORE) {
+  if (FlagSfiStore && N->getOpcode() == ISD::STORE) {
     return false;
   }
   // @LOCALMOD-END
diff -r 0efd1503eb30 lib/Target/ARM/ARMNaClHeaders.cpp
--- a/lib/Target/ARM/ARMNaClHeaders.cpp	Thu Mar 31 10:56:04 2011 -0400
+++ b/lib/Target/ARM/ARMNaClHeaders.cpp	Wed Jun 29 12:00:02 2011 -0700
@@ -20,10 +20,10 @@
 
 void EmitSFIHeaders(raw_ostream &O) {
   O << " @ ========================================\n";
-  O << "@ Branch: " << !FlagSfiDisableBranch << "\n";
-  O << "@ Stack: " << !FlagSfiDisableStack << "\n";
-  O << "@ Store: " << !FlagSfiDisableStore << "\n";
-  O << "@ Data: " << !FlagSfiDisableData << "\n";
+  O << "@ Branch: " << FlagSfiBranch << "\n";
+  O << "@ Stack: " << FlagSfiStack << "\n";
+  O << "@ Store: " << FlagSfiStore << "\n";
+  O << "@ Data: " << FlagSfiData << "\n";
 
   O << " @ ========================================\n";
   // NOTE: this macro does bundle alignment as follows
@@ -111,7 +111,7 @@
   }
 
   O << " @ ========================================\n";
-  if (!FlagSfiDisableBranch) {
+  if (FlagSfiBranch) {
     O <<
       "\t.macro sfi_call_preamble cond=\n"
       "\tsfi_nops_to_force_slot3\n"
@@ -143,7 +143,7 @@
 
   }
 
-  if (!FlagSfiDisableStore) {
+  if (FlagSfiStore) {
     O << " @ ========================================\n";
 
     O <<
diff -r 0efd1503eb30 lib/Target/ARM/ARMNaClRewritePass.cpp
--- a/lib/Target/ARM/ARMNaClRewritePass.cpp	Thu Mar 31 10:56:04 2011 -0400
+++ b/lib/Target/ARM/ARMNaClRewritePass.cpp	Wed Jun 29 12:00:02 2011 -0700
@@ -42,17 +42,16 @@
 FlagSfiZeroMask("sfi-zero-mask");
 
 cl::opt<bool>
-FlagSfiDisableData("sfi-data", cl::desc("disable using illegal at data bundle "
-                                        "beginning"));
+FlagSfiData("sfi-data", cl::desc("use illegal at data bundle beginning"));
 
 cl::opt<bool>
-FlagSfiDisableStore("sfi-store", cl::desc("disable sandboxing for stores"));
+FlagSfiStore("sfi-store", cl::desc("enable sandboxing for stores"));
 
 cl::opt<bool> 
-FlagSfiDisableStack("sfi-stack", cl::desc("disable sandboxing for stack changes"));
+FlagSfiStack("sfi-stack", cl::desc("enable sandboxing for stack changes"));
 
 cl::opt<bool>
-FlagSfiDisableBranch("sfi-branch", cl::desc("disable sandboxing for branches"));
+FlagSfiBranch("sfi-branch", cl::desc("enable sandboxing for branches"));
 
 }
 
@@ -631,9 +630,9 @@
        ++MFI) {
     MachineBasicBlock &MBB = *MFI;
 
-    if (!FlagSfiDisableStore)  Modified |= SandboxStoresInBlock(MBB);
-    if (!FlagSfiDisableBranch) Modified |= SandboxBranchesInBlock(MBB);
-    if (!FlagSfiDisableStack)  Modified |= SandboxStackChangesInBlock(MBB);
+    if (FlagSfiStore)  Modified |= SandboxStoresInBlock(MBB);
+    if (FlagSfiBranch) Modified |= SandboxBranchesInBlock(MBB);
+    if (FlagSfiStack)  Modified |= SandboxStackChangesInBlock(MBB);
   }
   DEBUG(LightweightVerify(MF));
   return Modified;
diff -r 0efd1503eb30 lib/Target/ARM/ARMNaClRewritePass.h
--- a/lib/Target/ARM/ARMNaClRewritePass.h	Thu Mar 31 10:56:04 2011 -0400
+++ b/lib/Target/ARM/ARMNaClRewritePass.h	Wed Jun 29 12:00:02 2011 -0700
@@ -16,10 +16,10 @@
 
 namespace llvm {
   extern cl::opt<bool> FlagSfiZeroMask;
-  extern cl::opt<bool> FlagSfiDisableData;
-  extern cl::opt<bool> FlagSfiDisableStore;
-  extern cl::opt<bool> FlagSfiDisableStack;
-  extern cl::opt<bool> FlagSfiDisableBranch;
+  extern cl::opt<bool> FlagSfiData;
+  extern cl::opt<bool> FlagSfiStore;
+  extern cl::opt<bool> FlagSfiStack;
+  extern cl::opt<bool> FlagSfiBranch;
 }
 
 namespace ARM_SFI {
diff -r 0efd1503eb30 lib/Target/ARM/ARMSubtarget.h
--- a/lib/Target/ARM/ARMSubtarget.h	Thu Mar 31 10:56:04 2011 -0400
+++ b/lib/Target/ARM/ARMSubtarget.h	Wed Jun 29 12:00:02 2011 -0700
@@ -23,7 +23,7 @@
 // @LOCALMOD-BEGIN
 #include "llvm/Support/CommandLine.h"
 namespace llvm {
-  extern cl::opt<bool> FlagSfiEnableCP;
+  extern cl::opt<bool> FlagSfiDisableCP;
 }
 // @LOCALMOD-END
 
@@ -219,13 +219,11 @@
 
   bool useMovt() const { return UseMovt && hasV6T2Ops(); }
 
-  // @LOCALMOD-START
-  bool isTargetNaCl() const {
-    return TargetTriple.getOS() == Triple::NativeClient;
-  }
+  // @LOCALMOD
+  bool useConstPool() const { return !FlagSfiDisableCP; }
 
-  bool useConstPool() const { return (!isTargetNaCl()) || FlagSfiEnableCP; }
-  // @LOCALMOD-END
+  // @LOCALMOD
+  bool isTargetNaCl() const { return TargetTriple.getOS() == Triple::NativeClient; }
 
   bool allowsUnalignedMem() const { return AllowsUnalignedMem; }
 
diff -r 0efd1503eb30 lib/Target/ARM/ARMTargetMachine.cpp
--- a/lib/Target/ARM/ARMTargetMachine.cpp	Thu Mar 31 10:56:04 2011 -0400
+++ b/lib/Target/ARM/ARMTargetMachine.cpp	Wed Jun 29 12:00:02 2011 -0700
@@ -26,15 +26,8 @@
 
 // @LOCALMOD-START
 namespace llvm {
-cl::opt<bool> FlagSfiEnableCP("sfi-enable-cp", cl::init(false), cl::Hidden,
-                              cl::desc("enable constant island pools in "
-                                       "text seg for NaCl (NaCl default "
-                                       "for constants is rodata)"));
-
-extern cl::opt<bool> FlagSfiDisableData;
-extern cl::opt<bool> FlagSfiDisableStore;
-extern cl::opt<bool> FlagSfiDisableStack;
-extern cl::opt<bool> FlagSfiDisableBranch;
+cl::opt<bool> FlagSfiDisableCP("sfi-disable-cp",
+                               cl::desc("disable arm constant island pools"));
 }
 // @LOCALMOD-END
 
@@ -200,30 +193,19 @@
     PM.add(createThumb2SizeReductionPass());
 
   // @LOCALMOD-START
-  // Note with isTargetNaCl() we effectively disable the
+  // Note with FlagSfiDisableCP we effectively disable the
   // ARMConstantIslandPass and rely on movt/movw to eliminate the need
   // for constant islands
-  if (Subtarget.isTargetNaCl()) {
-    assert(Subtarget.useMovt() && "ARM/NaCl requires movw/movt instruction");
+  if (FlagSfiDisableCP) {
+    assert(Subtarget.useMovt());
   }
-
-  /// FlagSfi* TRUE implies isTargetNaCl() TRUE
-  assert(((!FlagSfiDisableStore) || Subtarget.isTargetNaCl()) &&
-         "FlagSfiDisableStore can only be true in NaCl");
-  assert(((!FlagSfiDisableData) || Subtarget.isTargetNaCl()) &&
-         "FlagSfiDisableData can only be true in NaCl");
-  assert(((!FlagSfiDisableStack) || Subtarget.isTargetNaCl()) &&
-         "FlagSfiDisableStack can only be true in NaCl");
-  assert(((!FlagSfiDisableBranch) || Subtarget.isTargetNaCl()) &&
-         "FlagSfiDisableStack can only be true in NaCl");
   // @LOCALMOD-END
 
   PM.add(createARMConstantIslandPass());
   
   // @LOCALMOD-START
-  // This pass does all the heavy sfi lifting for ARM/SFI
-  if (Subtarget.isTargetNaCl())
-    PM.add(createARMNaClRewritePass());
+  // This pass does all the heavy sfi lifting. 
+  PM.add(createARMNaClRewritePass());
   // @LOCALMOD-END
  
   return true;
diff -r 0efd1503eb30 lib/Target/ARM/ARMTargetMachine.h
--- a/lib/Target/ARM/ARMTargetMachine.h	Thu Mar 31 10:56:04 2011 -0400
+++ b/lib/Target/ARM/ARMTargetMachine.h	Wed Jun 29 12:00:02 2011 -0700
@@ -32,7 +32,7 @@
 // @LOCALMOD-START
 #include "llvm/Support/CommandLine.h"
 namespace llvm {
-   extern cl::opt<bool> FlagSfiEnableCP;
+   extern cl::opt<bool> FlagSfiDisableCP;
 }
 // @LOCALMOD-END
 
