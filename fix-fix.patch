# HG changeset patch
# Parent c2f2db656031b4813ba725a6107b1da3ab1d27a1

diff -r c2f2db656031 llvm-trunk/tools/gold/gold-plugin.cpp
--- a/llvm-trunk/tools/gold/gold-plugin.cpp	Thu Jun 30 17:44:08 2011 -0700
+++ b/llvm-trunk/tools/gold/gold-plugin.cpp	Thu Jun 30 17:52:39 2011 -0700
@@ -228,10 +228,11 @@
 /// claim_file_hook - called by gold to see whether this file is one that
 /// our plugin can handle. We'll try to open it and register all the symbols
 /// with add_symbol if possible.
+#define PRINTF(m, ...)
 static ld_plugin_status claim_file_hook(const ld_plugin_input_file *file,
                                         int *claimed) {
   lto_module_t M;
-
+  PRINTF("**** scanning module %s\n", file->name);
   if (file->offset) {
     // Gold has found what might be IR part-way inside of a file, such as
     // an .a archive.
@@ -253,17 +254,18 @@
   cf.handle = file->handle;
   unsigned sym_count = lto_module_get_num_symbols(M);
   cf.syms.reserve(sym_count);
-
+  PRINTF("sym_count = %d\n", sym_count);
   for (unsigned i = 0; i != sym_count; ++i) {
     lto_symbol_attributes attrs = lto_module_get_symbol_attribute(M, i);
+    PRINTF ("**** ?? %s\n", const_cast<char *>(lto_module_get_symbol_name(M, i)));
     if ((attrs & LTO_SYMBOL_SCOPE_MASK) == LTO_SYMBOL_SCOPE_INTERNAL)
       continue;
-
     cf.syms.push_back(ld_plugin_symbol());
     ld_plugin_symbol &sym = cf.syms.back();
     sym.name = const_cast<char *>(lto_module_get_symbol_name(M, i));
     sym.name = strdup(sym.name);
     sym.version = NULL;
+    PRINTF("**** found symbol %s\n", sym.name);
 
     int scope = attrs & LTO_SYMBOL_SCOPE_MASK;
     switch (scope) {
@@ -351,6 +353,7 @@
          E = Modules.end(); I != E; ++I) {
     (*get_symbols)(I->handle, I->syms.size(), &I->syms[0]);
     for (unsigned i = 0, e = I->syms.size(); i != e; i++) {
+      PRINTF("**** %s %u \n", I->syms[i].name, (unsigned)I->syms[i].resolution);
       if (I->syms[i].resolution == LDPR_PREVAILING_DEF) {
         lto_codegen_add_must_preserve_symbol(code_gen, I->syms[i].name);
         anySymbolsPreserved = true;
diff -r c2f2db656031 llvm-trunk/tools/lto/LTOModule.cpp
--- a/llvm-trunk/tools/lto/LTOModule.cpp	Thu Jun 30 17:44:08 2011 -0700
+++ b/llvm-trunk/tools/lto/LTOModule.cpp	Thu Jun 30 17:52:39 2011 -0700
@@ -140,8 +140,8 @@
   }
 
   // parse bitcode buffer
-  OwningPtr<Module> m(getLazyBitcodeModule(buffer, getGlobalContext(),
-                                           &errMsg));
+  OwningPtr<Module> m(ParseBitcodeFile(buffer, getGlobalContext(), // @LOCALMOD
+                                       &errMsg));
   if (!m) {
     delete buffer;
     return NULL;
@@ -429,12 +429,26 @@
 
   entry.setValue(info);
 }
-
+// extern "C" void printf(const char *, ...);
+#define PRINTF(m, ...)
 void LTOModule::addPotentialUndefinedSymbol(GlobalValue *decl,
                                             Mangler &mangler) {
   // ignore all llvm.* symbols
   if (decl->getName().startswith("llvm."))
     return;
+  
+  PRINTF("decl->getName() = %s\n", decl->getName().data());
+  // @LOCALMOD-BEGIN
+  // Bitcode modules may have declarations for functions or globals
+  // which are unused. Ignore them here so that gold does not mistake
+  // them for undefined symbols. But don't ignore declarations for
+  // functions which are potentially used by intrinsics.
+  if (decl->use_empty() &&
+      !IntrinsicLowering::IsCalledByIntrinsic(decl->getName())) {
+    PRINTF("IGNORTING decl->getName() = %s\n", decl->getName().data());
+    return;
+  }
+  // @LOCALMOD-END
 
   // @LOCALMOD-BEGIN
   // Bitcode modules may have declarations for functions or globals
@@ -447,8 +461,10 @@
   // @LOCALMOD-END
 
   // ignore all aliases
-  if (isa<GlobalAlias>(decl))
+  if (isa<GlobalAlias>(decl)) {
+    PRINTF("IGNORTING ALIAS decl->getName() = %s\n", decl->getName().data());
     return;
+  }
 
   SmallString<64> name;
   mangler.getNameWithPrefix(name, decl, false);
@@ -457,8 +473,10 @@
     _undefines.GetOrCreateValue(name.c_str());
 
   // we already have the symbol
-  if (entry.getValue().name)
+  if (entry.getValue().name) {
+    PRINTF("IGNORTING DUP decl->getName() = %s\n", decl->getName().data());
     return;
+  }
 
   NameAndAttributes info;
 
