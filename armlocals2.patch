# HG changeset patch
# Parent 2933bf769155925f53fac5e514c09e11cd896edd
localmod: lib/Target/ARM/ARMMCInstLower.cpp lib/Target/ARM/ARMTargetMachine.cpp

diff -r 2933bf769155 -r 743118e60501 lib/Target/ARM/ARMMCInstLower.cpp
--- a/lib/Target/ARM/ARMMCInstLower.cpp	Mon Aug 08 17:00:23 2011 -0700
+++ b/lib/Target/ARM/ARMMCInstLower.cpp	Mon Aug 08 17:29:39 2011 -0700
@@ -123,3 +123,57 @@
       OutMI.addOperand(MCOp);
   }
 }
+
+// @LOCALMOD-BEGIN
+// Unlike LowerARMMachineInstrToMCInst, the opcode has already been set.
+// Otherwise, this is like LowerARMMachineInstrToMCInst, but with special
+// handling where the "immediate" is PC Relative
+// (used for MOVi16PIC / MOVTi16PIC, etc. -- see .td file)
+void llvm::LowerARMMachineInstrToMCInstPCRel(const MachineInstr *MI,
+                                             MCInst &OutMI,
+                                             ARMAsmPrinter &AP,
+                                             unsigned ImmIndex,
+                                             unsigned PCIndex,
+                                             MCSymbol *PCLabel,
+                                             unsigned PCAdjustment) {
+
+  for (unsigned i = 0, e = MI->getNumOperands(); i != e; ++i) {
+    if (i == ImmIndex) {
+      MCContext &Ctx = AP.OutContext;
+      const MCExpr *PCRelExpr = MCSymbolRefExpr::Create(PCLabel, Ctx);
+      if (PCAdjustment) {
+        const MCExpr *AdjExpr = MCConstantExpr::Create(PCAdjustment, Ctx);
+        PCRelExpr = MCBinaryExpr::CreateAdd(PCRelExpr, AdjExpr, Ctx);
+      }
+
+      // Get the usual symbol operand, then subtract the PCRelExpr.
+      const MachineOperand &MOImm = MI->getOperand(ImmIndex);
+      MCOperand SymOp;
+      bool DidLower = LowerARMMachineOperandToMCOperand(MOImm, MI, AP, SymOp);
+      assert (DidLower && "Immediate-like operand should have been lowered");
+
+      const MCExpr *Expr = SymOp.getExpr();
+      ARMMCExpr::VariantKind TargetKind = ARMMCExpr::VK_ARM_None;
+      /* Unwrap and rewrap the ARMMCExpr */
+      if (Expr->getKind() == MCExpr::Target) {
+        const ARMMCExpr *TargetExpr = cast<ARMMCExpr>(Expr);
+        TargetKind = TargetExpr->getKind();
+        Expr = TargetExpr->getSubExpr();
+      }
+      Expr = MCBinaryExpr::CreateSub(Expr, PCRelExpr, Ctx);
+      if (TargetKind != ARMMCExpr::VK_ARM_None) {
+        Expr = ARMMCExpr::Create(TargetKind, Expr, Ctx);
+      }
+      MCOperand MCOp = MCOperand::CreateExpr(Expr);
+      OutMI.addOperand(MCOp);
+    } else if (i == PCIndex) {  // dummy index already handled as PCLabel
+      continue;
+    } else {
+      MCOperand MCOp;
+      if (AP.lowerOperand(MI->getOperand(i), MCOp)) {
+        OutMI.addOperand(MCOp);
+      }
+    }
+  }
+}
+// @LOCALMOD-END
diff -r 2933bf769155 -r 743118e60501 lib/Target/ARM/ARMTargetMachine.cpp
--- a/lib/Target/ARM/ARMTargetMachine.cpp	Mon Aug 08 17:00:23 2011 -0700
+++ b/lib/Target/ARM/ARMTargetMachine.cpp	Mon Aug 08 17:29:39 2011 -0700
@@ -21,6 +21,13 @@
 #include "llvm/Target/TargetRegistry.h"
 using namespace llvm;
 
+// @LOCALMOD-START
+namespace llvm {
+cl::opt<bool> FlagSfiDisableCP("sfi-disable-cp",
+                               cl::desc("disable arm constant island pools"));
+}
+// @LOCALMOD-END
+
 extern "C" void LLVMInitializeARMTarget() {
   // Register the target.
   RegisterTargetMachine<ARMTargetMachine> X(TheARMTarget);
