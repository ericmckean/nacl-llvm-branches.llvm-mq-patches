# HG changeset patch
# Parent 8a854dd2f03e05446314981ebf60425022acda79
localmod: lib/Target/ARM/ARMAsmPrinter.h lib/Target/ARM/ARMBaseRegisterInfo.cpp lib/Target/ARM/ARMExpandPseudoInsts.cpp lib/Target/ARM/ARMISelDAGToDAG.cpp

diff -r 8a854dd2f03e -r d0ab6e8bd9d5 lib/Target/ARM/ARMAsmPrinter.h
--- a/lib/Target/ARM/ARMAsmPrinter.h	Mon Aug 08 15:38:34 2011 -0700
+++ b/lib/Target/ARM/ARMAsmPrinter.h	Mon Aug 08 16:35:51 2011 -0700
@@ -69,11 +69,27 @@
   virtual void EmitInstruction(const MachineInstr *MI);
   bool runOnMachineFunction(MachineFunction &F);
 
-  virtual void EmitConstantPool() {} // we emit constant pools customly!
+  // @LOCALMOD-START
+  // usually this does nothing on ARM as constants pools
+  // are handled with custom code.
+  // For the sfi case we do not use the custom logic and fall back
+  // to the default implementation.
+  virtual void EmitConstantPool() {
+    if (FlagSfiDisableCP) AsmPrinter::EmitConstantPool();
+  }
+  // @LOCALMOD-END
+
   virtual void EmitFunctionEntryLabel();
   void EmitStartOfAsmFile(Module &M);
   void EmitEndOfAsmFile(Module &M);
 
+  // @LOCALMOD-START
+  virtual bool UseReadOnlyJumpTables() const {
+    return true; // should be IsNaCl
+  }
+  virtual unsigned GetTargetLabelAlign(const MachineInstr *MI) const;
+  // @LOCALMOD-END
+
   // lowerOperand - Convert a MachineOperand into the equivalent MCOperand.
   bool lowerOperand(const MachineOperand &MO, MCOperand &MCOp);
 
diff -r 8a854dd2f03e -r d0ab6e8bd9d5 lib/Target/ARM/ARMBaseRegisterInfo.cpp
--- a/lib/Target/ARM/ARMBaseRegisterInfo.cpp	Mon Aug 08 15:38:34 2011 -0700
+++ b/lib/Target/ARM/ARMBaseRegisterInfo.cpp	Mon Aug 08 16:35:51 2011 -0700
@@ -19,6 +19,7 @@
 #include "ARMMachineFunctionInfo.h"
 #include "ARMSubtarget.h"
 #include "MCTargetDesc/ARMAddressingModes.h"
+#include "ARMTargetMachine.h"  // @LOCALMOD
 #include "llvm/Constants.h"
 #include "llvm/DerivedTypes.h"
 #include "llvm/Function.h"
diff -r 8a854dd2f03e -r d0ab6e8bd9d5 lib/Target/ARM/ARMExpandPseudoInsts.cpp
--- a/lib/Target/ARM/ARMExpandPseudoInsts.cpp	Mon Aug 08 15:38:34 2011 -0700
+++ b/lib/Target/ARM/ARMExpandPseudoInsts.cpp	Mon Aug 08 16:35:51 2011 -0700
@@ -762,15 +762,34 @@
     unsigned Hi16 = (Imm >> 16) & 0xffff;
     LO16 = LO16.addImm(Lo16);
     HI16 = HI16.addImm(Hi16);
-  } else {
+  } else if (MO.isGlobal()) { // @LOCALMOD
     const GlobalValue *GV = MO.getGlobal();
     unsigned TF = MO.getTargetFlags();
     LO16 = LO16.addGlobalAddress(GV, MO.getOffset(), TF | ARMII::MO_LO16);
     HI16 = HI16.addGlobalAddress(GV, MO.getOffset(), TF | ARMII::MO_HI16);
+  // @LOCALMOD-START - support for jumptable addresses and CPI
+  } else if (MO.isCPI()) {
+    int i = MO.getIndex();
+    unsigned TF = MO.getTargetFlags();
+    LO16 = LO16.addConstantPoolIndex(i, MO.getOffset(), TF|ARMII::MO_LO16);
+    HI16 = HI16.addConstantPoolIndex(i, MO.getOffset(), TF|ARMII::MO_HI16);
+  } else if (MO.isJTI()){
+    unsigned TF = MO.getTargetFlags();
+    LO16 = LO16.addJumpTableIndex(MO.getIndex(), TF | ARMII::MO_LO16);
+    HI16 = HI16.addJumpTableIndex(MO.getIndex(), TF | ARMII::MO_HI16);
+  } else {
+    assert (0 && "unexpected operand");
+  // @LOCALMOD-END
   }
-
+  // @LOCALMOD-BEGIN
+  if (ShouldUseMOV16PIC) {
+    AddPICADD_MOVi16_PICID(MI, MBB, MBBI, !isThumb2,
+                           PredReg, Pred, DstReg, DstIsDead, LO16, HI16);
+  }
+  // @LOCALMOD-END
   LO16->setMemRefs(MI.memoperands_begin(), MI.memoperands_end());
   HI16->setMemRefs(MI.memoperands_begin(), MI.memoperands_end());
+
   LO16.addImm(Pred).addReg(PredReg);
   HI16.addImm(Pred).addReg(PredReg);
 
@@ -946,8 +965,12 @@
     }
     case ARM::tTPsoft:
     case ARM::TPsoft: {
+      // @LOCALMOD-BEGIN
+      // Don't add implicit uses/defs for this call, otherwise
+      // liveness analysis passes get confused.
+      // @LOCALMOD-END
       MachineInstrBuilder MIB =
-        BuildMI(MBB, MBBI, MI.getDebugLoc(),
+        BuildMI_NoImp(MBB, MBBI, MI.getDebugLoc(), // @LOCALMOD
                 TII->get(Opcode == ARM::tTPsoft ? ARM::tBL : ARM::BL))
         .addExternalSymbol("__aeabi_read_tp", 0);
 
diff -r 8a854dd2f03e -r d0ab6e8bd9d5 lib/Target/ARM/ARMISelDAGToDAG.cpp
--- a/lib/Target/ARM/ARMISelDAGToDAG.cpp	Mon Aug 08 15:38:34 2011 -0700
+++ b/lib/Target/ARM/ARMISelDAGToDAG.cpp	Mon Aug 08 16:35:51 2011 -0700
@@ -145,7 +145,7 @@
   bool SelectAddrMode2OffsetImm(SDNode *Op, SDValue N,
                              SDValue &Offset, SDValue &Opc);
   bool SelectAddrOffsetNone(SDValue N, SDValue &Base);
-  bool SelectAddrMode3(SDValue N, SDValue &Base,
+  bool SelectAddrMode3(SDNode *Op, SDValue N, SDValue &Base,  // @LOCALMOD
                        SDValue &Offset, SDValue &Opc);
   bool SelectAddrMode3Offset(SDNode *Op, SDValue N,
                              SDValue &Offset, SDValue &Opc);
@@ -790,13 +790,19 @@
   if (isScaledConstantInRange(N, /*Scale=*/1, 0, 0x1000, Val))
     return false;
 
+  const bool is_store = (Opcode == ISD::STORE); // @LOCALMOD
+
+
   Offset = N;
   ARM_AM::ShiftOpc ShOpcVal = ARM_AM::getShiftOpcForNode(N.getOpcode());
   unsigned ShAmt = 0;
   if (ShOpcVal != ARM_AM::no_shift) {
     // Check to see if the RHS of the shift is a constant, if not, we can't fold
     // it.
-    if (ConstantSDNode *Sh = dyn_cast<ConstantSDNode>(N.getOperand(1))) {
+
+    //if (ConstantSDNode *Sh = dyn_cast<ConstantSDNode>(N.getOperand(1))) {
+    ConstantSDNode *Sh = dyn_cast<ConstantSDNode>(N.getOperand(1));
+    if ((!FlagSfiStore || !is_store) && Sh ) { // @LOCALMOD
       ShAmt = Sh->getZExtValue();
       if (isShifterOpProfitable(N, ShOpcVal, ShAmt))
         Offset = N.getOperand(0);
